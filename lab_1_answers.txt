----------------------------------------
		БЛОК 3
----------------------------------------
[[[[[[[[[[[ 1 ]]]]]]]]]]]
.length - кол-во эл-тов (А ТОЧНЕЕ .size)
.index() - индекс определенного эл-та
.first - первый эл-т (без индекса)
.last - последний эл-т (без индекса)
.push() - добавляет в конец
.delete() - удаляет по значению

.delete_at() - удаляет по позиции
.pop - удаляет последний эл-т
.shift - удаляет первый эл-т
эти трое возвращают удаленный эл-т

sharks.each { |shark| puts shark } - для работы с эл-тами массива, использован блок кода

["у", "попа", "была", "собака"].max                           #=> "у"      максимальный по значению
["у", "попа", "была", "собака"].max_by{ |elem| elem.size }    #=> "собака" максимальный по размеру строки

["у", "попа", "была", "собака"].min                           #=> "была" минимальный по значению
["у", "попа", "была", "собака"].min_by{ |elem| elem.size }    #=> "у"    минимальный по размеру строки

["у", "попа", "была", "собака"].sort	#=> ["была", "попа", "собака", "у"] сортировка по значению
["у", "попа", "была", "собака"].sort_by{ |elem| elem.size }	#=> ["у", "попа", "была", "собака"] сортировка по размеру строки

.reverse - обращение массива
.uniq - удаление дубликатов

arr1 | arr2 - объединение как множеств
arr1 & arr2 - пересечение как множеств

.flatten - сплющивание (из многомерного массива делает одномерный
array.compact - удаление nil элтов

array.include?() - есть ли эл-т в массиве
empty_array.empty? <=> empty_array  == [] <=> empty_array.size  == 0 - проверка на пустоту
array.any? - не пуст массив?

как получить все методы логические?
/////////////// CODE
puts nums2.methods.grep(/\?$/).sort
/////////////// CODE

[[[[[[[[[[[ 2 ]]]]]]]]]]]
days =  ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
days = %w{Monday Tuesday Wednesday Thursday Friday Saturday Sunday}
(1..6).to_a - Range -> Array
("a".."d").to_a    #=>  ["a", "b", "c", "d"]
Array.new(6){ |index| index + 1 } - метод из класса Array. (6) - кол-во эл-тов, {} - как заполняем

/////////////// CODE
days = %w{Monday Tuesday Wednesday Thursday Friday Saturday Sunday}
puts "DAYS #{days} #{days.class} of #{days[0].class}"

nums = (1..6).to_a
puts "NUMS #{nums} #{nums.class} of #{nums[0].class}"

nums2 = Array.new(6){ |index| index + 1 }
puts "NUMS #{nums2} #{nums2.class} of #{nums2[0].class}"
/////////////// CODE


[[[[[[[[[[[ 3 ]]]]]]]]]]]
sharks[3] = "whale"; - просто по индексу можно добавить, если пропустили какой-то то nil добавляется на пропущенные
sharks.push("thresher") - добавляет в конец массива элемент[ы]
nums2.append(1, 4) - добавляет в конец массива элемент[ы]
nums2.unshift(0, 0, 0) - добавляет в начало массива элемент[ы]
nums2.prepend(0, 0, 0) - добавляет в начало массива элемент[ы]
sharks << “Bullhead” - добавляет в конец массива элемент
nums2.insert(1, "2") - добавляет в любую позицию индекса (причем не на место, а "раздвигает массив")

[[[[[[[[[[[ 4 ]]]]]]]]]]]
array = ["a", "b", "c", "d", "e"]
INDEXES:
"a" -> 0, -5
"b" -> 1, -4
"c" -> 2, -3
"d" -> 3, -2
"e" -> 4, -1

array[1..-2]	#=> ["b", "c", "d"]
array[1...-1]	#=> ["b", "c", "d"]
ТРИ ТОЧКИ - не включается последний индекс

[[[[[[[[[[[ 5 ]]]]]]]]]]]
Файл можно открыть с помощью следующей конструкции:
f = File.open(path, mode)
mode -> r, 
	r+ (чтение и запись начиная с начала файла),
	w (если существует файл, то перезапишется),
	w+ (досутпна операция чтения),
	a (если существует файл, то дописываться будет),
	а+ (плюс операция чтения).
f.close - ЗАКРЫТИЕ ФАЙЛА


Метод gets возвращает прочитанную строку или nil, если файл был прочитан до конца.
С помощью метода getc из файла можно прочитать ровно один символ. Он так же возвращает nil, если файл уже был целиком прочитан.
Метод readline отличается от gets тем, что генерирует ошибку в случае достижения конца файла, а не возвращает nil.
Метод readlines читает все строки файла и возвращает их в виде массива. 
Как и методу gets, методу readlines можно указать, что считать разделителем строк и каким числом байт ограничиться, если нет необходимости читать весь файл.

В отличие от метода puts, метод print не вставляет между строковыми представлениями объектов перенос строки и не завершает им вывод. 
Если переопределить специальную переменную $,, то между печатаемыми объектами будет вставлен указанный разделитель. Пример:
print 1, 2, 3 # => 123
$, = ", "
print 1, 2, 3 # => 1, 2, 3
С помощью метода flush можно переместить данные из буфера в файл.

каретку установить можно с помощью seek:
File::SEEK_CUR — отсчет от текущей позиции каретки. Первый аргумент может принимать отрицательные значения.
File::SEEK_END — отсчет от конца файла. Для сдвига влево так же необходимо использовать отрицательные значения.
File::SEEK_SET — отсчет от начала файла. Первый аргумент положительный.

или pos:
f.pos = 13
Текущую позицию в файле можно узнать с помощью метода pos:
f.pos # => 13